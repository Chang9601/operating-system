#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/wait.h>

#define TERMINAL 1
#define BUF_SIZE 50

int
main(int argc, char *argv[])
{
  pid_t pid;

  /*
   * pid_t fork(void)를 기존 프로세스가 호출하여 새로운 프로세스를 생성할 수 있다. 새로운 프로세스를 자식 프로세스라고 한다.
   * 함수는 한 번 호출되지만 두 번 반환한다. 자식 프로세스에는 0이 반환되고 부모 프로세스에는 새로운 자식의 프로세스 아이디가 반환된다.
   * 자식 프로세스 아이디가 부모 프로세스에게 반환되는 이유는 프로세스가 여러 개의 자식 프로세스를 가질 수 있고 프로세스가 자식 프로세스의 아이디를 얻을 수 있는 함수가 없기 때문이다. 
   * 자식 프로세스에 0을 반환하는 이유는 프로세스가 단일 부모 프로세스만 가질 수 있으며 자식 프로세스는 항상 getppid() 함수를 호출하여 부모 프로세스의 아이디를 얻을 수 있기 때문이다(프로세스 아이디 0은 커널에서 사용하기 위해 예약되어 있으므로 0이 자식 프로세스의 아이디가 될 수 없다.).
   * 자식 프로세스와 부모 프로세스는 함수 호출 다음에 따르는 명령으로 계속 실행된다. 자식 프로세스는 부모 프로세스의 복사본이다. 
   * 자식은 부모의 데이터 영역, 힙 영역, 및 스택 영역의 복사본을 받는다. 부모 프로세스와 자식 프로세스는 이 메모리 영역을 공유하지 않는다. 
   * 그러나 부모 프로세스와 자식 프로세스는 텍스트 영역을 공유한다. 현대적인 구현은 부모 프로세스의 데이터 영역, 스택 영역, 및 힙 영역을 완전한 복사하지 않는데 함수 다음에는 exec() 함수가 자주 따르기 때문이다. 
   * 대신 복사본 작성 시(copy-on-write, COW)라는 기술이 사용되며 이러한 메모리 영역은 부모 프로세스와 자식 프로세스에 의해 공유되며 커널에 의해 읽기 전용으로 보호가 변경된다. 
   * 두 프로세스 중 하나가 이러한 메모리 영역을 수정하려고 하면 커널은 해당 메모리 조각의 복사본을 만든다. 일반적으로 가상 메모리 시스템에서 페이지이다.
   * 일반적으로 어느 프로세스가 먼저 실행되는지 알 수 없다. 순서는 커널이 사용하는 스케줄링 알고리즘에 달려있다. 자식 프로세스와 부모 프로세스의 동기화가 필요한 경우 IPC가 필요하다.
   * 
   * 함수의 한 특징은 부모 프로세스에 열려 있는 모든 파일 기술자가 자식 프로세스에 복제된다는 것이다. 
   * "복제"라고 말하는 이유는 각 파일 기술자에 대해 dup() 함수가 호출된 것처럼 동작하기 때문이다. 
   * 부모 프로세스와 자식 프로세스는 열려 있는 각 파일 기술자에 대해 파일 테이블 항목을 공유한다.
   * 부모 프로세스와 자식 프로세스가 동일한 파일 오프셋을 공유하는 것이 중요하다.
   * 
   * 부모 프로세스와 자식 프로세스가 동일한 파일 기술자에 쓰는 경우, 부모 프로세스가 자식 프로세스을 기다리는 것과 같이 동기화가 없다면 출력이 혼합될 수 있다(e.g., 함수 이전에 열려 있던 파일 기술자를 사용한다고 가정한다.). 
   * 함수 이후 파일 기술자를 처리하는 두 가지 정상적인 경우가 있다.
   * 1. 부모 프로세스가 자식 프로세스가 완료될 때까지 기다린다. 이 경우, 부모 프로세스는 파일 기술자에 대해 아무것도 할 필요가 없다. 자식 프로세스가 종료되면 자식 프로세스가 읽거나 쓴 공유 파일 기술자의 파일 오프셋이 이에 따라 갱신된다.
   * 2. 부모 프로세스와 자식 프로세스가 각자의 방식으로 진행한다. 함수 이후에 부모 프로세스는 필요하지 않은 파일 기술자를 닫고 자식 프로세스도 마찬가지로 한다. 이렇게 함으로써 각각이 서로의 열린 파일 기술자에 간섭하지 않는다.
   */
  if ((pid = fork()) < 0) {
    exit(EXIT_FAILURE);
  } else if (pid == 0) { /* 자식 프로세스 */
    char *msg = "자식 프로세스의 우선순위는 ";
    char *child_prio = calloc(BUF_SIZE, sizeof(*child_prio));
    
    /*
     * int getpriority(int which, id_t who) 함수는 프로세스의 우선순위를 반환하며 which 인자는 3가지 값 중 하나를 취할 수 있다.
     * 1. PRIO_PROCESS: 프로세스.
     * 2. PRIO_PGRP: 프로세스 그룹.
     * 3. PRIO_USER: 사용자 아이디.
     * which 인자는 who 인자의 해석 방법을 제어하고 who 인자는 관심 있는 프로세스나 프로세스를 선택한다. 
     * 만약 who 인자가 0이면 호출하는 프로세스, 프로세스 그룹 또는 사용자를 나타낸다(which 인자의 값에 따라 다르다.). 
     * which 인자가 PRIO_USER로 설정되고 who 인자가 0인 경우, 호출하는 프로세스의 실제 사용자 아이디가 사용된다. 
     * which 인자가 여러 프로세스에 적용되는 경우 적용되는 모든 프로세스 중에서 가장 높은 우선순위(가장 낮은 값)가 반환된다.
     * 
     * pid_t getpid(void) 함수는 호출 프로세스의 프로세스 아이디를 반환한다.
     */
    strncat(child_prio, msg, strlen(msg));
    sprintf(child_prio + strlen(child_prio), "%d", getpriority(PRIO_PROCESS, getpid()));
    strncat(child_prio, "\n", 1);

    write(TERMINAL, child_prio, strlen(child_prio));
    free(child_prio);
  } else { /* 부모 프로세스 */
    /*
     * 프로세스가 정상적으로나 비정상적으로 종료될 때 커널은 부모 프로세스에게 SIGCHLD 신호를 보낸다. 
     * 자식 프로세스의 종료는 비동기적인 이벤트이기 때문에 부모 프로세스가 실행 중일 때 언제든지 발생할 수 있으므로 이 신호는 커널로부터 부모 프로세스에게 비동기적 알림이다. 
     * 부모 프로세스는 신호를 무시하거나 신호가 발생할 때 호출되는 함수인 신호 핸들러를 제공할 수 있다. 기본 동작은 신호를 무시하는 것이다.
     * 
     * wait() 함수 혹은 waitpid() 함수를 호출한 프로세스
     * 1. 모든 자식 프로세스 아직 실행 중이면 블록될 수 있다.
     * 2. 자식 프로세스가 종료되었고 종료 상태가 검색되기를 기다리고 있는 경우 자식 프로세스의 종료 상태로 즉시 반환될 수 있다.
     * 3. 자식 프로세스가 없는 경우 오류로 즉시 반환될 수 있다.
     *
     * pid_t wait(int *statloc) vs. pid_t waitpid(pid_t pid, int *statloc, int options)
     * 1. wait() 함수는 호출자를 자식 프로세스가 종료될 때까지 블록할 수 있지만 waitpid() 함수는 블록되지 않도록 하는 옵션이 있다.
     * 2. waitpid() 함수는 처음 종료된 자식 프로세스를 기다리지 않으며 어떤 프로세스를 기다릴지를 제어하는 여러 옵션이 있다.
     * 
     * 자식 프로세스가 이미 종료되어 좀비인 경우, wait() 함수는 그 자식 프로세스의 상태로 즉시 반환한다. 그렇지 않으면, 호출자는 자식 프로세스가 종료될 때까지 블록된다. 
     * 호출자가 블록되고 여러 자식 프로세스가 있는 경우, wait() 함수는 하나가 종료될 때 반환된다. 프로세스 아이디가 반환되므로 어떤 자식 프로세스가 종료되었는지 항상 알 수 있다.
     * 
     * 특정 프로세스가 종료될 때까지 기다려야 하는 경우 프로세스 아이디를 반환된 프로세스 아이디와 비교하기 위해 wait() 함수를 반복적으로 호출해야 한다.
     * waitpid() 함수가 특정 프로세스를 기다리는 함수이다. waitpid() 함수의 pid 인자의 해석은 그 값에 따라 달라진다.
     * pid == −1: 어떤 자식 프로세스든 기다리는데 wait() 함수와 동등하다.
     * pid > 0: 프로세스 아이디가 pid와 같은 자식을 기다린다.
     * pid == 0: 호출 프로세스와 동일한 프로세스 그룹 아이디를 가진 어떤 자식이든 기다린다.
     * pid < −1: pid의 절댓값과 동일한 프로세스 그룹 아이디를 가진 어떤 자식이든 기다린다.
     */
    waitpid(pid, NULL, 0);

    char *msg = "부모 프로세스의 우선순위는 ";
    char *parent_prio = calloc(BUF_SIZE, sizeof(parent_prio));
    
    strncat(parent_prio, msg, strlen(msg));
    sprintf(parent_prio + strlen(parent_prio), "%d", getpriority(PRIO_PROCESS, getpid()));
    strncat(parent_prio, "\n", 1);

    write(TERMINAL, parent_prio, strlen(parent_prio));
    free(parent_prio);
  }

  exit(EXIT_SUCCESS);
}